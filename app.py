import streamlit as st
import pandas as pd
import json
import yfinance as yf
import os
import streamlit.components.v1 as components
from datetime import datetime

# -----------------------------------------------------------------------------
# 1. PAGE CONFIGURATION & STYLING
# -----------------------------------------------------------------------------
st.set_page_config(
    page_title="Alpha Scout Terminal",
    page_icon="ðŸ¦…",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# Force Dark Theme CSS adjustments for metrics and tables
st.markdown("""
    <style>
    /* Card styling for Metrics */
    div[data-testid="stMetric"] {
        background-color: #1E1E1E;
        border: 1px solid #333;
        padding: 15px;
        border-radius: 8px;
    }
    /* Table headers styling */
    th {
        background-color: #262730 !important;
        color: #FAFAFA !important;
    }
    /* Success/Error text colors */
    .st-emotion-cache-16idsys p { font-size: 1.1rem; }
    </style>
    """, unsafe_allow_html=True)

# -----------------------------------------------------------------------------
# 2. DATA LOADING & CACHING
# -----------------------------------------------------------------------------

FILE_JSON = "data/latest_report.json"
FILE_CSV = "data/performance_log.csv"

def load_latest_report():
    """Reads the JSON generated by ScoutReport.model_dump_json()"""
    if os.path.exists(FILE_JSON):
        try:
            with open(FILE_JSON, "r") as f:
                data = json.load(f)
                # alpha_scout.py saves a ScoutReport object which has a 'catalysts' list
                return data.get("catalysts", [])
        except json.JSONDecodeError:
            return []
    return []

def load_performance_log():
    """Reads the CSV log"""
    if os.path.exists(FILE_CSV):
        try:
            # Backend headers: Timestamp_NY, Ticker, Entry_Price, Conviction, Market_Cap, ATR_14, Stop_Loss, Target_Price...
            df = pd.read_csv(FILE_CSV)
            return df
        except Exception as e:
            st.error(f"Error loading CSV: {e}")
            return pd.DataFrame()
    return pd.DataFrame()

@st.cache_data(ttl=300, show_spinner=False)
def fetch_live_batch_prices(tickers):
    """
    Fetches live prices for a list of tickers. 
    Cached for 5 minutes (300s) to prevent API rate limits.
    """
    if not tickers:
        return {}
    
    unique_tickers = list(set(tickers))
    price_map = {}
    
    try:
        # Batch download is efficient
        data = yf.download(
            tickers=" ".join(unique_tickers), 
            period="1d", 
            group_by='ticker', 
            progress=False,
            threads=True
        )
        
        # Handle case for single ticker vs multiple tickers structure
        for t in unique_tickers:
            try:
                if len(unique_tickers) == 1:
                    # Dataframe is just OHLCV for one ticker
                    price = data['Close'].iloc[-1]
                else:
                    # Dataframe is MultiIndex: (Ticker, OHLCV)
                    price = data[t]['Close'].iloc[-1]
                price_map[t] = price
            except Exception:
                price_map[t] = None
    except Exception as e:
        print(f"YFinance Error: {e}")
        
    return price_map

# -----------------------------------------------------------------------------
# 3. COMPONENT RENDERING
# -----------------------------------------------------------------------------

def render_tradingview_widget(ticker):
    """Embeds TradingView chart"""
    html_code = f"""
    <div class="tradingview-widget-container">
      <div id="tradingview_chart"></div>
      <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
      <script type="text/javascript">
      new TradingView.widget(
      {{
        "width": "100%",
        "height": 500,
        "symbol": "{ticker}",
        "interval": "D",
        "timezone": "America/New_York",
        "theme": "dark",
        "style": "1",
        "locale": "en",
        "toolbar_bg": "#f1f3f6",
        "enable_publishing": false,
        "allow_symbol_change": true,
        "container_id": "tradingview_chart"
      }}
      );
      </script>
    </div>
    """
    components.html(html_code, height=500)

# -----------------------------------------------------------------------------
# 4. MAIN LAYOUT
# -----------------------------------------------------------------------------

st.title("ðŸ¦… Alpha Scout Terminal")
st.caption(f"System Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

tab_signal, tab_history = st.tabs(["ðŸ“¡ Active Signals", "ðŸ“œ Performance History"])

# --- TAB 1: ACTIVE SIGNALS (FROM JSON) ---
with tab_signal:
    catalysts = load_latest_report()
    
    if catalysts:
        # Display the top conviction pick (first in list usually, or highest score)
        # Assuming backend sorts them, if not we sort here:
        catalysts.sort(key=lambda x: x.get('conviction_score', 0), reverse=True)
        top_pick = catalysts[0]
        
        ticker = top_pick.get('ticker')
        # Handle cases where backend values might be strings or floats
        try:
            target_price = float(top_pick.get('target_price', 0))
            # Clean stop loss string (e.g. "$150.00 (Trailing...)") -> 150.00
            stop_raw = str(top_pick.get('stop_loss_trigger', '0'))
            import re
            stop_match = re.search(r"[\d\.]+", stop_raw)
            stop_price = float(stop_match.group()) if stop_match else 0.0
            
            # Fetch generic price for display comparison if needed, 
            # though JSON has 'current_price' (AI estimate/Snapshot)
            display_price = top_pick.get('current_price')
        except:
            display_price = 0
            target_price = 0
            stop_price = 0

        # Header
        col_head, col_btn = st.columns([3, 1])
        with col_head:
            st.subheader(f"Top Conviction: ${ticker}")
        with col_btn:
            st.link_button(
                "Trade on Robinhood ðŸ¹", 
                f"https://robinhood.com/us/en/stocks/{ticker}/",
                type="primary",
                use_container_width=True
            )

        st.markdown("---")

        # Metrics
        m1, m2, m3, m4 = st.columns(4)
        m1.metric("Entry Zone", f"${display_price:.2f}")
        m2.metric("Target", f"${target_price:.2f}", help="3.0 ATR Calculation")
        m3.metric("Stop Loss", f"${stop_price:.2f}", help="1.5 ATR Trailing")
        m4.metric("Conviction", f"{top_pick.get('conviction_score')}/10")

        # Details
        c1, c2 = st.columns([1, 1])
        with c1:
            st.info(f"**Thesis:** {top_pick.get('thesis')}")
            st.write(f"**Catalyst:** {top_pick.get('catalyst_details')}")
        with c2:
            st.warning(f"**Risks:** {top_pick.get('risk')}")
            st.write(f"**Absorption:** {top_pick.get('absorption_status')}")

        st.write("### Live Chart")
        render_tradingview_widget(ticker)
        
        # If there are other signals, show them briefly below
        if len(catalysts) > 1:
            st.markdown("---")
            st.write("#### Other Candidates")
            for c in catalysts[1:]:
                st.text(f"{c.get('ticker')} | Score: {c.get('conviction_score')} | {c.get('thesis')}")

    else:
        st.info("Waiting for backend signal generation... Check `data/latest_report.json`.")

# --- TAB 2: HISTORY & PERFORMANCE (FROM CSV) ---
with tab_history:
    df = load_performance_log()
    
    if not df.empty and 'Ticker' in df.columns:
        # 1. Prepare Data
        # Map Backend CSV headers to UI friendly names if necessary, 
        # but we need specific calculations first.
        
        # Get unique tickers to fetch live price
        tickers = df['Ticker'].unique().tolist()
        
        with st.spinner("Syncing live market data..."):
            live_prices = fetch_live_batch_prices(tickers)
        
        # 2. Add Computed Columns
        df['Current Price'] = df['Ticker'].map(live_prices)
        
        # Ensure numeric types
        df['Entry_Price'] = pd.to_numeric(df['Entry_Price'], errors='coerce')
        df['Current Price'] = pd.to_numeric(df['Current Price'], errors='coerce')
        
        # Calculate Performance %
        def calc_perf(row):
            if pd.notnull(row['Current Price']) and row['Entry_Price'] > 0:
                return ((row['Current Price'] - row['Entry_Price']) / row['Entry_Price']) * 100
            return 0.0

        df['Performance %'] = df.apply(calc_perf, axis=1)
        
        # 3. Rename Columns for Display (Subset of available columns)
        # Backend: Timestamp_NY, Ticker, Entry_Price, Conviction, Market_Cap, ATR_14, Stop_Loss, Target_Price, Thesis...
        display_df = df[[
            'Timestamp_NY', 'Ticker', 'Entry_Price', 'Current Price', 
            'Stop_Loss', 'Performance %', 'Status'
        ]].copy()
        
        display_df.rename(columns={
            'Timestamp_NY': 'Alert Date',
            'Entry_Price': 'Entry Price',
            'Stop_Loss': 'ATR Stop Loss'
        }, inplace=True)

        # Sort by Date desc
        display_df['Alert Date'] = pd.to_datetime(display_df['Alert Date'])
        display_df = display_df.sort_values(by='Alert Date', ascending=False)

        # 4. Interactive Table
        st.write("### Signal Performance Log")
        
        # Use selection_mode to detect clicks (Streamlit 1.35+)
        event = st.dataframe(
            display_df,
            use_container_width=True,
            hide_index=True,
            selection_mode="single-row",
            on_select="rerun",
            column_config={
                "Alert Date": st.column_config.DatetimeColumn("Alert Date", format="MM-DD HH:mm"),
                "Entry Price": st.column_config.NumberColumn("Entry", format="$%.2f"),
                "Current Price": st.column_config.NumberColumn("Live Price", format="$%.2f"),
                "Performance %": st.column_config.NumberColumn(
                    "Perf %", 
                    format="%.2f%%",
                    help="Live PnL based on Entry vs Current"
                ),
            }
        )
        
        # 5. Dynamic Charting Logic
        selected_ticker = None
        
        # Try to get selection from event
        rows = event.selection.rows
        if rows:
            selected_index = rows[0]
            # Since we sorted display_df, we must use iloc on the sorted dataframe
            selected_ticker = display_df.iloc[selected_index]['Ticker']
        elif not display_df.empty:
            # Default to top most recent
            selected_ticker = display_df.iloc[0]['Ticker']
            
        if selected_ticker:
            st.divider()
            st.caption(f"Analyzing History: {selected_ticker}")
            render_tradingview_widget(selected_ticker)
            
    else:
        st.warning("No performance history found. CSV is missing or empty.")